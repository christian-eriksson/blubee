#!/bin/sh

. ./json_utils.sh
. ./string_utils.sh

print_help() {
    echo "usage: blubee -b <backup.json> [options] <command>\n"
    echo "command:"
    echo "  backup"
    echo "\tCreate backups as described by <backup.json>.\n"
    echo "  restore"
    echo "\tRestore backups described in <backup.json>.\n"
    echo "  dry [backup|restore]"
    echo "\tDo a dry run for the choosen command.\n"
    echo "options:"
    echo "\t-b <backup-json>\tpath to backup config"
    echo "\t-c <config-file>\tpath to custom blubee config"
    echo "\t-h\t\t\tprint this help"
}

panic() {
    print_help
    exit 1
}

while getopts ":hb:c:" option; do
    case "${option}" in
        b)
            backup_json_file=$OPTARG;;
        c)
            config_file=$OPTARG;;
        h)
            panic
            ;;
        :)
            echo "Missing argument for option '$OPTARG'"
            panic
            ;;
        ?)
            echo "Unrecognized option '$OPTARG'";;
    esac
done

command=$(echo $@ | cut -d' ' -f$OPTIND)
if [ -z "$command" ]; then
    echo "No command specified.\n"
    panic
fi

if [ -z "$backup_json_file" ]; then
    echo "No backup json specified, use the -b option.\n"
    panic
fi

if [ ! -z "$config_file" ]; then
    . $config_file
fi

backup() {
    backup_json="$1"
    additional_options="$2"

    backup_configs=$(get_json_element '.backup_configs' "$backup_json")

    destination_path=$(get_json_element ".backup_destination" "$backup_json")
    [ -z "$destination_path" ] && echo "No backup destination path in 'backup.json'!" && panic
    destination_path=$(trim_right_slash "$(dequote_string "$destination_path")")

    configs_count=$(list_length "$backup_configs")
    config_index=0
    while [ "$config_index" -lt "$configs_count" ]; do
        config=$(get_list_item "$backup_configs" "$config_index")

        config_name=$(get_json_element ".name" "$config")
        [ -z "$config_name" ] && echo "Can not have config without name in 'backup.json'" && panic
        config_name=$(trim_left_slash "$(dequote_string "$config_name")")

        source_root=$(get_json_element ".root" "$config")
        [ -z "$source_root" ] && echo "No source root for config '$config_name'!" && panic
        source_root=$(trim_right_slash "$(dequote_string "$source_root")")

        sources_list=$(get_json_element ".paths" "$config")
        [ -z "sources_list" ] && echo "No source paths for '$config_name'!" && panic
        sources=$(extract_json_list "$sources_list")
        [ -z "$sources" ] && echo "No sources in config '$config_name'!" && panic

        ./backup.sh -r "$source_root" -s "$sources"  -d "$destination_path/$config_name" $additional_options
        config_index=$((config_index + 1))
    done
}

restore() {
    backup_json="$1"
    [ ! -z "$2" ] && restore_backup_copy="-b $2"
    additional_options="$3"

    backups_path=$(get_json_element '.backup_destination' "$backup_json")
    [ -z "$backups_path" ] && echo "No backup destination path in 'backup.json'!" && panic
    backups_path=$(trim_right_slash "$(dequote_string "$backups_path")")

    backup_configs=$(get_json_element '.backup_configs' "$backup_json")
    configs_count=$(list_length "$backup_configs")
    config_index=0
    while [ "$config_index" -lt "$configs_count" ]; do
        config=$(get_list_item "$backup_configs" "$config_index")

        config_name=$(get_json_element ".name" "$config")
        [ -z "$config_name" ] && echo "Can not have config without name in 'backup.json'" && panic
        config_name=$(trim_left_slash "$(dequote_string "$config_name")")

        restore_path=$(get_json_element ".root" "$config")
        [ -z "$restore_path" ] && echo "No source root for config '$config_name'!" && panic
        restore_path=$(trim_right_slash "$(dequote_string "$restore_path")")

        sources_list=$(get_json_element ".paths" "$config")
        [ -z "sources_list" ] && echo "No source paths for '$config_name'!" && panic
        sources=$(extract_json_list "$sources_list")
        [ -z "$sources" ] && echo "No sources in config '$config_name'!" && panic

        ./restore.sh -r "$restore_path" -s "$backups_path/$config_name" -p "$sources" $restore_backup_copy $additional_options
        config_index=$((config_index + 1))
    done
}

backup_config_json=$(cat $backup_json_file)
case "$command" in
    backup)
        backup "$backup_config_json"
        ;;
    restore)
        restore "$backup_config_json" "$RESTORE_BACKUP_COPY"
        ;;
    dry)
        sub_command_index=$(expr $OPTIND + 1)
        [ $sub_command_index -gt $# ] && echo "You need to pass a command to run in dry mode!" && panic
        sub_command=$(echo $@ | cut -d' ' -f$sub_command_index)
        case "$sub_command" in
            backup)
                backup "$backup_config_json" "-x"
                ;;
            restore)
                restore "$backup_config_json" "$RESTORE_BACKUP_COPY" "-x"
                ;;
            *)
                echo "Unrecognized sub command for dry run '$sub_command'.\n"
                panic
                ;;
        esac
        ;;
    *)
        echo "Unrecognized command '$command'.\n"
        panic
        ;;
esac

